{
    "0001_unindexed_foreign_keys": "(\nwith foreign_keys as (\n    select\n        cl.relnamespace::regnamespace as schema_,\n        cl.oid::regclass as table_,\n        ct.conname as fkey_name,\n        ct.conkey col_attnums\n    from\n        pg_catalog.pg_constraint ct\n        join pg_catalog.pg_class cl -- fkey owning table\n            on ct.conrelid = cl.oid\n        left join pg_catalog.pg_depend d\n            on d.objid = cl.oid\n            and d.deptype = 'e'\n    where\n        ct.contype = 'f' -- foreign key constraints\n        and d.objid is null -- exclude tables that are dependencies of extensions\n        and cl.relnamespace::regnamespace::text not in (\n            'pg_catalog', 'information_schema', 'auth', 'storage', 'vault', 'extensions'\n        )\n),\nindex_ as (\n    select\n        indrelid::regclass as table_,\n        indexrelid::regclass as index_,\n        string_to_array(indkey::text, ' ')::smallint[] as col_attnums\n    from\n        pg_catalog.pg_index\n    where\n        indisvalid\n)\nselect\n    'unindexed_foreign_keys' as name,\n    'INFO' as level,\n    'EXTERNAL' as facing,\n    'Identifies foreign key constraints without a covering index, which can impact database performance.' as description,\n    format(\n        'Table \\`%s.%s\\` has a foreign key \\`%s\\` without a covering index. This can lead to suboptimal query performance.',\n        fk.schema_,\n        fk.table_,\n        fk.fkey_name\n    ) as detail,\n    'https://supabase.github.io/splinter/0001_unindexed_foreign_keys' as remediation,\n    jsonb_build_object(\n        'schema', fk.schema_,\n        'name', fk.table_,\n        'type', 'table',\n        'fkey_name', fk.fkey_name,\n        'fkey_columns', fk.col_attnums\n    ) as metadata,\n    format('unindexed_foreign_keys_%s_%s_%s', fk.schema_, fk.table_, fk.fkey_name) as cache_key\nfrom\n    foreign_keys fk\n    left join index_ idx\n        on fk.table_ = idx.table_\n        and fk.col_attnums = idx.col_attnums\nwhere\n    idx.index_ is null\n    and fk.schema_::text not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\norder by\n    fk.table_,\n    fk.fkey_name)",
    "0002_auth_users_exposed": "(\nselect\n    'auth_users_exposed' as name,\n    'WARN' as level,\n    'EXTERNAL' as facing,\n    'Detects if auth.users is exposed to anon or authenticated roles via a view or materialized view in the public schema, potentially compromising user data security.' as description,\n    format(\n        'View/Materialized View \"%s\" in the public schema may expose \\`auth.users\\` data to anon or authenticated roles.',\n        c.relname\n    ) as detail,\n    'https://supabase.github.io/splinter/0002_auth_users_exposed' as remediation,\n    jsonb_build_object(\n        'schema', 'public',\n        'name', c.relname,\n        'type', 'view',\n        'exposed_to', array_remove(array_agg(DISTINCT case when pg_catalog.has_table_privilege('anon', c.oid, 'SELECT') then 'anon' when pg_catalog.has_table_privilege('authenticated', c.oid, 'SELECT') then 'authenticated' end), null)\n    ) as metadata,\n    format('auth_users_exposed_%s_%s', 'public', c.relname) as cache_key\nfrom\n    -- Identify the oid for auth.users\n\tpg_catalog.pg_class auth_users_pg_class\n    join pg_catalog.pg_namespace auth_users_pg_namespace\n\t\ton auth_users_pg_class.relnamespace = auth_users_pg_namespace.oid\n\t\tand auth_users_pg_class.relname = 'users'\n\t\tand auth_users_pg_namespace.nspname = 'auth'\n\t-- Depends on auth.users\n    join pg_catalog.pg_depend d\n    \ton d.refobjid = auth_users_pg_class.oid\n    join pg_catalog.pg_rewrite r\n        on r.oid = d.objid\n    join pg_catalog.pg_class c\n        on c.oid = r.ev_class\n    join pg_catalog.pg_namespace n\n        on n.oid = c.relnamespace\n    join pg_catalog.pg_class pg_class_auth_users\n        on d.refobjid = pg_class_auth_users.oid\nwhere\n    d.deptype = 'n'\n    and n.nspname = 'public'\n    and (\n      pg_catalog.has_table_privilege('anon', c.oid, 'SELECT')\n      or pg_catalog.has_table_privilege('authenticated', c.oid, 'SELECT')\n    )\n    -- Exclude self\n    and c.relname <> '0002_auth_users_exposed'\n    -- There are 3 insecure configurations\n    and\n    (\n        -- Materialized views don't support RLS so this is insecure by default\n        (c.relkind in ('m')) -- m for materialized view\n        or\n        -- Standard View, accessible to anon or authenticated that is security_definer\n        (\n            c.relkind = 'v' -- v for view\n            -- Exclude security invoker views \n            and not (\n                lower(coalesce(c.reloptions::text,'{}'))::text[]\n                && array[\n                    'security_invoker=1',\n                    'security_invoker=true',\n                    'security_invoker=yes',\n                    'security_invoker=on'\n                ]\n            )\n        )\n        or\n        -- Standard View, security invoker, but no RLS enabled on auth.users\n        (\n            c.relkind in ('v') -- v for view\n            -- is security invoker \n            and (\n                lower(coalesce(c.reloptions::text,'{}'))::text[]\n                && array[\n                    'security_invoker=1',\n                    'security_invoker=true',\n                    'security_invoker=yes',\n                    'security_invoker=on'\n                ]\n            )\n            and not pg_class_auth_users.relrowsecurity \n        )\n    )\ngroup by\n    c.relname, c.oid)",
    "0003_auth_rls_initplan": "(/*\nUsage of auth.uid(), auth.role() ... are common in RLS policies.\n\nA naive policy like\n\n    create policy \"rls_test_select\" on test_table\n    to authenticated\n    using ( auth.uid() = user_id )\n\nwill re-evaluate the auth.uid() function for every row. That can result in 100s of times slower performance\nhttps://supabase.com/docs/guides/database/postgres/row-level-security#call-functions-with-select\n\nTo resolve that issue, the function calls can be wrapped like \"(select auth.uid())\" which causes the value to\nbe executed exactly 1 time per query\n\nFor example:\n\n    create policy \"rls_test_select\" on test_table\n    to authenticated\n    using ( (select auth.uid()) = user_id )\n\nNOTE:\n    This lint requires search_path = '' or 'auth' not in search_path\n    because qual and with_check are dependent on search_path to determine if function calls include the \"auth\" schema\n*/\n\n\n\nwith policies as (\n    select\n        nsp.nspname as schema_,\n        polrelid::regclass table_,\n        pc.relrowsecurity is_rls_active,\n        polname as policy_name,\n        polpermissive as is_permissive, -- if not, then restrictive\n        (select array_agg(r::regrole) from unnest(polroles) as x(r)) as roles,\n        case polcmd\n            when 'r' then 'SELECT'\n            when 'a' then 'INSERT'\n            when 'w' then 'UPDATE'\n            when 'd' then 'DELETE'\n            when '*' then 'ALL'\n        end as command,\n        qual,\n        with_check\n    from\n        pg_catalog.pg_policy pa\n        join pg_catalog.pg_class pc\n            on pa.polrelid = pc.oid\n        join pg_catalog.pg_namespace nsp\n            on pc.relnamespace = nsp.oid\n        join pg_catalog.pg_policies pb\n            on pc.relname = pb.tablename\n            and nsp.nspname = pb.schemaname\n            and pa.polname = pb.policyname\n)\nselect\n    'auth_rls_initplan' as name,\n    'WARN' as level,\n    'EXTERNAL' as facing,\n    'Detects if calls to \\`auth.<function>()\\` in RLS policies are being unnecessarily re-evaluated for each row' as description,\n    format(\n        'Table \\`%s\\` has a row level security policy \\`%s\\` that re-evaluates an auth.<function>() for each row. This produces suboptimal query performance at scale. Resolve the issue by replacing \\`auth.<function>()\\` with \\`(select auth.<function>())\\`. See https://supabase.com/docs/guides/database/postgres/row-level-security#call-functions-with-select for more.',\n        table_,\n        policy_name\n    ) as detail,\n    'https://supabase.github.io/splinter/0003_auth_rls_initplan' as remediation,\n    jsonb_build_object(\n        'schema', schema_,\n        'name', table_,\n        'type', 'table'\n    ) as metadata,\n    format('auth_rls_init_plan_%s_%s_%s', schema_, table_, policy_name) as cache_key\nfrom\n    policies\nwhere\n    is_rls_active\n    and schema_::text not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\n    and (\n        (\n            -- Example: auth.uid()\n            qual  ~ '(auth)\\.(uid|jwt|role|email)\\(\\)'\n            -- Example: select auth.uid()\n            and lower(qual) !~ 'select\\s+(auth)\\.(uid|jwt|role|email)\\(\\)'\n        )\n        or\n        (\n            -- Example: auth.uid()\n            with_check  ~ '(auth)\\.(uid|jwt|role|email)\\(\\)'\n            -- Example: select auth.uid()\n            and lower(with_check) !~ 'select\\s+(auth)\\.(uid|jwt|role|email)\\(\\)'\n        )\n    ))",
    "0004_no_primary_key": "(\nselect\n    'no_primary_key' as name,\n    'INFO' as level,\n    'EXTERNAL' as facing,\n    'Detects if a table does not have a primary key. Tables without a primary key can be inefficient to interact with at scale.' as description,\n    format(\n        'Table \\`%s.%s\\` does not have a primary key',\n        pgns.nspname,\n        pgc.relname\n    ) as detail,\n    'https://supabase.github.io/splinter/0004_no_primary_key' as remediation,\n     jsonb_build_object(\n        'schema', pgns.nspname,\n        'name', pgc.relname,\n        'type', 'table'\n    ) as metadata,\n    format(\n        'no_primary_key_%s_%s',\n        pgns.nspname,\n        pgc.relname\n    ) as cache_key\nfrom\n    pg_catalog.pg_class pgc\n    join pg_catalog.pg_namespace pgns\n        on pgns.oid = pgc.relnamespace\n    left join pg_catalog.pg_index pgi\n        on pgi.indrelid = pgc.oid\nwhere\n    pgc.relkind = 'r' -- regular tables\n    and pgns.nspname not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\ngroup by\n    pgc.oid,\n    pgns.nspname,\n    pgc.relname\nhaving\n    max(coalesce(pgi.indisprimary, false)::int) = 0)",
    "0005_unused_index": "(\nselect\n    'unused_index' as name,\n    'INFO' as level,\n    'EXTERNAL' as facing,\n    'Detects if an index has never been used and may be a candidate for removal.' as description,\n    format(\n        'Index \\`%s\\` on table \\`%s.%s\\` has not been used',\n        psui.indexrelname,\n        psui.schemaname,\n        psui.relname\n    ) as detail,\n    'https://supabase.github.io/splinter/0005_unused_index' as remediation,\n    jsonb_build_object(\n        'schema', psui.schemaname,\n        'name', psui.relname,\n        'type', 'table'\n    ) as metadata,\n    format(\n        'unused_index_%s_%s_%s',\n        psui.schemaname,\n        psui.relname,\n        psui.indexrelname\n    ) as cache_key\n\nfrom\n    pg_catalog.pg_stat_user_indexes psui\n    join pg_catalog.pg_index pi\n        on psui.indexrelid = pi.indexrelid\nwhere\n    psui.idx_scan = 0\n    and not pi.indisunique\n    and not pi.indisprimary\n    and psui.schemaname not in (\n        'pg_catalog', 'information_schema', 'auth', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    ))",
    "0006_multiple_permissive_policies": "(\nselect\n    'multiple_permissive_policies' as name,\n    'WARN' as level,\n    'EXTERNAL' as facing,\n    'Detects if multiple permissive row level security policies are present on a table for the same `role` and `action` (e.g. insert). Multiple permissive policies are suboptimal for performance as each policy must be executed for every relevant query.' as description,\n    format(\n        'Table \\`%s.%s\\` has multiple permissive policies for role \\`%s\\` for action \\`%s\\`. Policies include \\`%s\\`',\n        n.nspname,\n        c.relname,\n        r.rolname,\n        act.cmd,\n        array_agg(p.polname order by p.polname)\n    ) as detail,\n    'https://supabase.github.io/splinter/0006_multiple_permissive_policies' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as metadata,\n    format(\n        'multiple_permissive_policies_%s_%s_%s_%s',\n        n.nspname,\n        c.relname,\n        r.rolname,\n        act.cmd\n    ) as cache_key\nfrom\n    pg_catalog.pg_policy p\n    join pg_catalog.pg_class c on p.polrelid = c.oid\n    join pg_catalog.pg_namespace n on c.relnamespace = n.oid\n    join pg_catalog.pg_roles r\n        on p.polroles @> array[r.oid]\n        or p.polroles = array[0::oid],\n    lateral (\n        select x.cmd\n        from unnest((\n            select\n                case p.polcmd\n                    when 'r' then array['SELECT']\n                    when 'a' then array['INSERT']\n                    when 'w' then array['UPDATE']\n                    when 'd' then array['DELETE']\n                    when '*' then array['SELECT', 'INSERT', 'UPDATE', 'DELETE']\n                    else array['ERROR']\n                end as actions\n        )) x(cmd)\n    ) act(cmd)\nwhere\n    c.relkind = 'r' -- regular tables\n    and n.nspname not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\n    and r.rolname not like 'pg_%'\n    and r.rolname not like 'supabase%admin'\n    and not r.rolbypassrls\ngroup by\n    n.nspname,\n    c.relname,\n    r.rolname,\n    act.cmd\nhaving\n    count(1) > 1)",
    "0007_policy_exists_rls_disabled": "(\nselect\n    'policy_exists_rls_disabled' as name,\n    'INFO' as level,\n    'EXTERNAL' as facing,\n    'Detects cases where row level security (RLS) policies have been created, but RLS has not been enabled for the underlying table.' as description,\n    format(\n        'Table \\`%s.%s\\` has RLS policies but RLS is not enabled on the table. Policies include %s.',\n        n.nspname,\n        c.relname,\n        array_agg(p.polname order by p.polname)\n    ) as detail,\n    'https://supabase.github.io/splinter/0007_policy_exists_rls_disabled' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as metadata,\n    format(\n        'policy_exists_rls_disabled_%s_%s',\n        n.nspname,\n        c.relname\n    ) as cache_key\nfrom\n    pg_catalog.pg_policy p\n    join pg_catalog.pg_class c\n        on p.polrelid = c.oid\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\nwhere\n    c.relkind = 'r' -- regular tables\n    and n.nspname not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\n    -- RLS is disabled\n    and not c.relrowsecurity\ngroup by\n    n.nspname,\n    c.relname)",
    "0008_rls_enabled_no_policy": "(\nselect\n    'rls_enabled_no_policy' as name,\n    'INFO' as level,\n    'EXTERNAL' as facing,\n    'Detects cases where row level security (RLS) has been enabled on a table but no RLS policies have been created.' as description,\n    format(\n        'Table \\`%s.%s\\` has RLS enabled, but no policies exist',\n        n.nspname,\n        c.relname\n    ) as detail,\n    'https://supabase.github.io/splinter/0008_rls_enabled_no_policy' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as metadata,\n    format(\n        'rls_enabled_no_policy_%s_%s',\n        n.nspname,\n        c.relname\n    ) as cache_key\nfrom\n    pg_catalog.pg_class c\n    left join pg_catalog.pg_policy p\n        on p.polrelid = c.oid\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\nwhere\n    c.relkind = 'r' -- regular tables\n    and n.nspname not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\n    -- RLS is enabled\n    and c.relrowsecurity\n    and p.polname is null\ngroup by\n    n.nspname,\n    c.relname)",
    "0009_duplicate_index": "(\nselect\n    'duplicate_index' as name,\n    'WARN' as level,\n    'EXTERNAL' as facing,\n    'Detects cases where two ore more identical indexes exist.' as description,\n    format(\n        'Table \\`%s.%s\\` has identical indexes %s. Drop all except one of them',\n        n.nspname,\n        c.relname,\n        array_agg(pi.indexname order by pi.indexname)\n    ) as detail,\n    'https://supabase.github.io/splinter/0009_duplicate_index' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', case\n            when c.relkind = 'r' then 'table'\n            when c.relkind = 'm' then 'materialized view'\n            else 'ERROR'\n        end,\n        'indexes', array_agg(pi.indexname order by pi.indexname)\n    ) as metadata,\n    format(\n        'duplicate_index_%s_%s_%s',\n        n.nspname,\n        c.relname,\n        array_agg(pi.indexname order by pi.indexname)\n    ) as cache_key\nfrom\n    pg_catalog.pg_indexes pi\n    join pg_catalog.pg_namespace n\n        on n.nspname  = pi.schemaname\n    join pg_catalog.pg_class c\n        on pi.tablename = c.relname\n        and n.oid = c.relnamespace\nwhere\n    c.relkind in ('r', 'm') -- tables and materialized views\n    and n.nspname not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\ngroup by\n    n.nspname,\n    c.relkind,\n    c.relname,\n    replace(pi.indexdef, pi.indexname, '')\nhaving\n    count(*) > 1)",
    "0010_security_definer_view": "(\nselect\n    'security_definer_view' as name,\n    'WARN' as level,\n    'EXTERNAL' as facing,\n    'Detects views that are SECURITY DEFINER meaning that they ignore row level security (RLS) policies.' as description,\n    format(\n        'View \\`%s.%s\\` is SECURITY DEFINER',\n        n.nspname,\n        c.relname\n    ) as detail,\n    'https://supabase.github.io/splinter/0010_security_definer_view' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'view'\n    ) as metadata,\n    format(\n        'security_definer_view_%s_%s',\n        n.nspname,\n        c.relname\n    ) as cache_key\nfrom\n    pg_catalog.pg_class c\n    join pg_catalog.pg_namespace n\n        on n.oid = c.relnamespace\nwhere\n    c.relkind = 'v'\n    and n.nspname = 'public'\n\tand not (\n\t\tlower(coalesce(c.reloptions::text,'{}'))::text[]\n\t\t&& array[\n\t\t\t'security_invoker=1',\n\t\t\t'security_invoker=true',\n\t\t\t'security_invoker=yes',\n\t\t\t'security_invoker=on'\n\t\t]\n\t))",
    "0011_function_search_path_mutable": "(\nselect\n    'function_search_path_mutable' as name,\n    'WARN' as level,\n    'EXTERNAL' as facing,\n    'Detects functions with a mutable search_path parameter which could fail to execute sucessfully for some roles.' as description,\n    format(\n        'Function \\`%s.%s\\` has a role mutable search_path',\n        n.nspname,\n        p.proname\n    ) as detail,\n    'https://supabase.github.io/splinter/0011_function_search_path_mutable' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', p.proname,\n        'type', 'function'\n    ) as metadata,\n    format(\n        'function_search_path_mutable_%s_%s_%s',\n        n.nspname,\n        p.proname,\n        md5(p.prosrc) -- required when function is polymorphic\n    ) as cache_key\nfrom\n    pg_catalog.pg_proc p\n    join pg_catalog.pg_namespace n\n        on p.pronamespace = n.oid\nwhere\n    n.nspname not in (\n        'pg_catalog', 'information_schema', 'auth', 'extensions', 'graphql', 'graphql_public', 'net', 'pgsodium', 'storage', 'supabase_functions', 'vault'\n    )\n    -- Search path not set to ''\n    and not coalesce(p.proconfig, '{}') && array['search_path=\"\"'])",
    "0013_rls_disabled_in_public": "(\nselect\n    'rls_disabled_in_public' as name,\n    'ERROR' as level,\n    'EXTERNAL' as facing,\n    'Detects cases where row level security (RLS) has not been enabled on a table in the `public` schema.' as description,\n    format(\n        'Table \\`%s.%s\\` is public, but RLS has not been enabled.',\n        n.nspname,\n        c.relname\n    ) as detail,\n    'https://supabase.github.io/splinter/0013_rls_disabled_in_public' as remediation,\n    jsonb_build_object(\n        'schema', n.nspname,\n        'name', c.relname,\n        'type', 'table'\n    ) as metadata,\n    format(\n        'rls_disabled_in_public_%s_%s',\n        n.nspname,\n        c.relname\n    ) as cache_key\nfrom\n    pg_catalog.pg_class c\n    join pg_catalog.pg_namespace n\n        on c.relnamespace = n.oid\nwhere\n    c.relkind = 'r' -- regular tables\n    and n.nspname = 'public'\n    -- RLS is disabled\n    and not c.relrowsecurity)"
}